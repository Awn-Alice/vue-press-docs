(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{365:function(r,a,t){"use strict";t.r(a);var v=t(43),e=Object(v.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"_01-双线程模型：为什么小程序不用浏览器的线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01-双线程模型：为什么小程序不用浏览器的线程模型"}},[r._v("#")]),r._v(" 01 | 双线程模型：为什么小程序不用浏览器的线程模型")]),r._v(" "),t("h2",{attrs:{id:"浏览器并不是单线程而是多进程的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器并不是单线程而是多进程的"}},[r._v("#")]),r._v(" "),t("strong",[r._v("浏览器并不是单线程而是多进程的")])]),r._v(" "),t("br"),r._v(" "),t("p",[r._v("事实上，浏览器内部架构很复杂，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式")]),r._v(" "),t("p",[r._v("Chrome 为每个标签页开启了一个独立的渲染进程（ Renderer Process ），每个进程之间的资源（ CPU、内存等）和行为（ UI、逻辑等）互不共享，所以即便某个标签页崩溃了也不会影响其他标签页，")]),r._v(" "),t("p",[r._v("浏览器会把不同的工作交给对应的线程，比如 GUI 渲染线程负责把 HTML 渲染成可视化的 UI；JavaScript 引擎线程负责解析和运行 JavaScript 代码逻辑；定时触发器线程负责处理 setTimeout/setInterval 定时器等")]),r._v(" "),t("p",[t("strong",[r._v("我多说一句，这里有一个很容易搞混的误区：")]),r._v(" setTimeout/setInterval 并不是 JavaScript 语言的一部分，而是运行时（最初是浏览器，后来 Node.js 也提供了支持）提供的能力。")]),r._v(" "),t("p",[r._v("接着说回来，其中 GUI 渲染线程和 JavaScript 引擎线程是互斥的，JavaScript 在执行期间会阻塞 UI 的渲染，甚至如果脚本执行时间太长会由于页面长时间无响应然后崩溃，正是 GUI 渲染线程和 JavaScript 引擎线程之间的这种互斥、阻塞的线程管理方式，让一部分前端开发者以为浏览器是单线程的")]),r._v(" "),t("p",[t("strong",[r._v("那为什么 JavaScript 被设计成单线程的呢？")])]),r._v(" "),t("p",[r._v("在运行机制上，JavaScript 并没有像 Java 那样提供多线程能力，最主要就是为了避免多线程操作 DOM 造成 UI 冲突。比如存在多个线程同时操作同一个 DOM，浏览器该如何判断最终的 UI 效果是采用哪个线程的结果？这是经典的线程安全（也称为线程同步）问题，在多线程编程领域有很多解决方案，比如加入锁机制，但这样却又带来了更多的复杂性，与 JavaScript 简单易用的设计初衷相违背。")]),r._v(" "),t("p",[r._v("这同时也解释了为什么 GUI 渲染线程与 JavaScript 引擎线程是互斥的：JavaScript 代码有修改DOM 的权限。")]),r._v(" "),t("p",[r._v("当 JavaScript 代码被执行时，GUI 渲染线程会被挂起，等待 JavaScript 引擎线程空闲时再被执行，以免在渲染期间被 JavaScript 重复地修改 DOM 造成不必要的渲染压力。采用互斥的模式等待 JavaScript 代码执行完毕后，可以保证渲染是最终的执行结果。所以浏览器的空闲（Idle）时长也成了衡量网站性能的重要指标之一，空闲时长多代表 JavaScript 逻辑不密集以及 DOM改动频率低，这种情况下浏览器可以更快速顺畅地响应用户的交互行为，如下图：")]),r._v(" "),t("p",[t("img",{attrs:{src:"img/%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4.png",alt:"alt 图片"}})]),r._v(" "),t("p",[r._v("后来，HTML5 引入了 Web Worker，提供多线程执行 JavaScript 代码的能力，但是与其他编程语言不同的是，Worker 线程与主线程并不是扁平的，而是一种主从（ Master-Slave）多线程模型。")]),r._v(" "),t("p",[r._v("Worker 内的 JavaScript 代码不能操作 DOM，可以将其理解为线程安全的。你要记住这一点，这是后面讲小程序双线程模型一个重要的基础。\n"),t("br"),t("br")]),r._v(" "),t("h2",{attrs:{id:"为什么小程序不使用浏览器的线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么小程序不使用浏览器的线程模型"}},[r._v("#")]),r._v(" "),t("strong",[r._v("为什么小程序不使用浏览器的线程模型")])]),r._v(" "),t("br"),r._v(" "),t("p",[r._v("Web Worker 是线程安全的，Worker 内的 JavaScript 代码无法获取 Window 和 Document 对象，也就无法操作 DOM。除此之外，由于 Worker 的线程安全特性，Worker 内的代码运行过程中不会阻塞外层的 GUI 渲染线程，两者可以并行。")]),r._v(" "),t("p",[r._v("这样就形成了一个简易的双线程模型：Worker 线程负责计算，将结果通过 postMessage 传递给主线程，主线程负责渲染。\n"),t("img",{attrs:{src:"img/web-work.jpg",alt:"alt web worker线程图片",title:"web-work线程"}})]),r._v(" "),t("p",[r._v("但是这个模型存在比较严重的性能问题，Web Worker 非常耗费资源，除去计算消耗以外，与主线程的通信过程对性能的损耗也非常严重。\n"),t("br"),t("br")]),r._v(" "),t("h2",{attrs:{id:"安全高效的小程序双线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全高效的小程序双线程模型"}},[r._v("#")]),r._v(" "),t("strong",[r._v("安全高效的小程序双线程模型")])]),r._v(" "),t("br"),r._v(" "),t("p",[r._v("小程序需要既能够像 Web 一样将资源托管在云端，更新独立；同时又能够保证足够好的安全性和性能。所以最终小程序采用了 Hybrid-混合的架构模式："),t("strong",[r._v("使用 Webview 渲染 UI、使用类似Web Worker 的独立线程运行逻辑，这就是接下来要讲的双线程模型。")]),r._v(" "),t("br"),t("br")]),r._v(" "),t("h2",{attrs:{id:"渲染线程和逻辑线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染线程和逻辑线程"}},[r._v("#")]),r._v(" "),t("strong",[r._v("渲染线程和逻辑线程")])]),r._v(" "),t("br"),r._v(" "),t("p",[r._v("小程序的双线程指的就是渲染线程和逻辑线程，这两个线程分别承担UI的渲染和执行 JavaScript 代码的工作。如下图所示：\n"),t("img",{attrs:{src:"img/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E7%BA%BF%E7%A8%8B.jpg",alt:"alt 小程序的双线程"}})]),r._v(" "),t("p",[r._v("渲染线程使用 Webview 进行 UI 的渲染呈现。Webview 是一个完整的类浏览器运行环境，本身具备运行 JavaScript 的能力，但是小程序并不是将逻辑脚本放到 Webview 中运行，而是将逻辑层独立为一个与 Webview 平行的线程，使用客户端提供的 JavaScript 引擎运行代码，iOS 的JavaScriptCore、安卓是腾讯 X5 内核提供的 JsCore 环境以及 IDE 工具的 nwjs 。")]),r._v(" "),t("p",[r._v("并且逻辑线程是一个只能够运行 JavaScript 的沙箱环境，不提供 DOM 操作相关的 API，所以不能直接操作 UI，只能够通过 setData 更新数据的方式异步更新 UI。\n"),t("br"),t("br")]),r._v(" "),t("h2",{attrs:{id:"事件驱动的通信方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动的通信方式"}},[r._v("#")]),r._v(" "),t("strong",[r._v("事件驱动的通信方式")])]),r._v(" "),t("br"),r._v(" "),t("p",[r._v("你要注意上图渲染线程和逻辑线程之间的通信方式，与 Vue/React 不同的是，小程序的渲染层与逻辑层之间的通信并不是在两者之间直接传递数据或事件，而是由 Native 作为中间媒介进行转发。")]),r._v(" "),t("p",[r._v("整个过程是典型的事件驱动模式：")]),r._v(" "),t("ul",[t("li",[r._v("渲染层（也可以称为视图层）通过与用户的交互触发特定的事件 event；")]),r._v(" "),t("li",[r._v("然后 event 被传递给逻辑层；")]),r._v(" "),t("li",[r._v("逻辑层继而通过一系列的逻辑处理、数据请求、接口调用等行为将加工好的数据 data 传递给渲染层；")]),r._v(" "),t("li",[r._v("最后渲染层将 data 渲染为可视化的 UI。")])]),r._v(" "),t("p",[t("strong",[r._v("而这样逻辑与渲染分离的线程分工模式一方面能够保证运行在逻辑线程沙箱内的 JavaScript 代码是线程安全的，另一方面由于渲染线程的计算量非常小从而保证了对用户交互行为的快速响应，提高了用户体验。")])]),r._v(" "),t("p",[r._v("总的来说，跟浏览器的线程模型相比，小程序的双线程模型解决了或者说规避了 Web Worker 堪忧的性能同时又实现了与 Web Worker 相同的线程安全，从性能和安全两个角度实现了提升。可以概括地说，双线程模式是受限于浏览器现有的进程和线程管理模式之下，在小程序这一具体场景之内的一种改进的架构方案。")])])}),[],!1,null,null,null);a.default=e.exports}}]);