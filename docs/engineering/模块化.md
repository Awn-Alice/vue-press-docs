# CommonJS 与 ES6 Module


`CommonJS | 动态 | 模块依赖关系的建立发生在代码运行阶段`

`ES6 Module | 静态 | 模块依赖关系建立发生在代码编译阶段`

`导入模块时，CommonJS是导出值的拷贝，ES6 Module是值的动态映射，CommonJS导出的值可以修改，且不影响基值；ES6 Module导出的值不可修改`

参考资料：<https://juejin.cn/post/6844904137159606285>

## CommonJS规范

**每个模块内部有两个变量可以使用require 和 module**

* **require 用来加载某个模块**

    `require的模块路径可以动态指定，支持 传入一个表达式`

    `require命令的基本功能是，读入并执行一个 js 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错`

    `CommonJS模块的加载机制是，require的是被导出的值的拷贝。也就是说，一旦导出一个值，模块内部的变化就影响不到这个值`

* **module 代表当前模块，是一个对象，保存了当前模块的信息。exports 是 module 上的一个属性，保存了当前模块要导出的接口或者变量，使用 require 加载的某个模块获取到的值就是那个模块使用 exports 导出的值**

## ES6 Module

**ES6 Module是一个静态的模块结构，在ES6 代码 *编译阶段* 就可以分析出模块的依赖关系**

* 导入模块时，CommonJS是导出值的拷贝，ES6 Module是值的动态映射，并且这个映射是只读的。
* 死代码检测和排除，通过静态分析工具检测出哪些模块没被调用过。比如引入工具类库时，工程可能只 用到了某一个接口，但可能将整个工具包都加载进来了，未被调用的代码永远不会被执行。通过静态分析 可以在打包时去掉这些未使用的模块，减少打包资源体积。
* 模块变量类型检查，js属于动态类型语言，不会再代码执行前检查类型错误。例如将字符串类型进行函数调用。 ES6 Module的静态模块结构可以确保模块之间传递的值或接口类型正确。
* 编译器优化，CommonJS本质上是导入一个对象，ES6 Module支持导入变量，减少了引用层级，程序效率更高