# 02 | 授权模型： 小程序的用户体系与 OAuth 规范

## **如何搭建微信小程序的登录流程？**

<br/>

1. **小程序使用微信登录的优势**

    **从生态系统的角度上，** 相对于其他应用端，以微信为入口的小程序最大的优势是拥有微信完善的生态系统，用户使用微信登录后可以使用微信提供给小程序的各种平台级能力，比如订阅消息、微信支付等。

    **从用户体验的角度上，** 用户能够很大程度上降低登录的复杂程度。想象一下，对比在小程序内用用户名密码登录和一键微信登录，哪种方式更容易被用户接受呢？结果不言而喻。

    **从产品策略的角度上，** 使用微信登录小程序能够根据用户的来源，制定特殊的产品策略，比如对于小程序的用户发放专属的优惠券。

    所以，你可以由此得出小程序使用微信登录的三个主要优势：

    * 融入微信生态；

    * 提高用户体验；

    * 制定产品策略。

    **下面这张图清晰地描绘了微信小程序完整的登录流程、角色以及相关术语。**
    ![alt](img/小程序登陆流程.jpg '小程序的登陆流程')
    **整个登录流程中描述了三种角色和六个术语，了解它们的定位和作用，是理解小程序登录流程的基础。**
    ![alt](img/三个角色和六个术语.jpg)

2. **登录流程里的三个角色**

    客户端在整个登录流程中主要承担两种行为：
    * 作为整个流程的发起者，获取临时登录凭证 code；
    * 作为整个流程的终结者，存储登录态令牌 token。

    不过客户端的所有信息和网络请求几乎都是可以被破解或拦截的，所以出于安全的考虑，小程序登录流程中的一些接口被限制不能在客户端中直接调用，而是需要在服务端发起，**开发者服务**的工作便是处理这些安全敏感的网络请求，体现为上图中使用code 获取 openid 和 session_key的请求，这个请求使用了微信提供的 auth.code2Session 接口。

    而**微信接口服务**的工作对于开发者来说是不透明的，你需要做的仅仅是根据接口的规范，组装网络请求发送给它，然后根据返回的接口执行分发逻辑。微信服务器会验证网络请求的合法性，对于合法请求下发密钥 session_key 和用户 openid。

3. **登录流程的六个术语**

    * **code**

    它是在客户端（即小程序）内通过 wx.login API 获取的，然后通过 HTTP 请求发送给开发者服务器。code 的作用体现在“临时”两字上，它的有效期限仅有 5 分钟，并且仅能够使用一次（即请求一次 auth.code2Session 接口）。

    * **appid**

    每个微信小程序在创建之后（即在微信公众平台注册并初始化完成）便同时生成了一appid，这个 ID 标记了小程序的唯一性，等同于网站的URL（经过备案的）、App 的包名等标记应用唯一性的信息。

    * **appsecret**

    它是小程序的密钥，可以在微信公众平台的后台管理系统中获取。appsecret　是非常私密的信息，所以微信在制定小程序登录的流程时，将携带此信息的网络请求限制在只能通过开发者服务器发送给微信接口服务，这样对于客户端来说是不可见的，进而降低了被泄露的可能性。与appid 不同的是，appsecret 可以被重置，但每次重置之后，历史的 appsecret 便会失效，所以请谨慎操作。

    * **openid**

    微信号在某个应用程序中的唯一 ID。这里的“某个应用程序”指的是小程序、公众号、接入开放平台的应用。微信生态中目前有公众平台和开放平台两种，其中公众平台又细分为小程序和公众号，开放平台可以接入网站、移动应用等。同一个微信号在不同的应用程序中有不同的 openid。

    在微信生态下另外有一个标记微信号的唯一 ID：UnionId。这个 ID 跟应用程序无关。所以，**可以简单地理解为 openid是 UnionId 与 appid 综合加密后的结果**，见下图：
    ![alt](img/openid.jpg)

    * **session_key**

    session_key 是对用户数据进行加密签名的密钥，微信服务器使用它将用户的数据进行加密和解密。你可以简单地将 session_key 理解为获取用户数据的“绿卡”，登录之后所有涉及访问微信服务器的请求一般都需要带上它，微信服务器会校验 session_key 的合法性。

    * **token（这一段为什么把session_key直接返回了，待考究）**

    登录态是个逻辑词汇，token 可以理解为登录态的具象化、数据化。在小程序的登录流程图中，你可以看出，token是由开发者服务器创建的一个字符串，而且需要跟 openid 和 session_key 相关联。其实这里并不是强制关联 openid，因为 openid 并不算是私密信息，可以放心地下发到客户端（即小程序）。但是 session_key 是非常私密的信息，一旦泄露有很大的安全隐患，所以强烈建议不要把它下发到客户端。

    在获取到 openid 和 session_key 之后，开发者服务器创建一个 token，然后与 openid 和session_key 进行关联，具体的方法根据服务器编程语言的不同有多种实现方案。咱们以JavaScript 语言作为示例，可以创建一个对象，对象的 key 是 token 的值，value 是一个包含 openid 和 session_key 的对象，如下：

        {
            "token_1": {
                "openid": "获取到的openid 1",
                "session_key": "获取到的session_key 1"
            }，
            "token_2": {
                "openid": "获取到的openid 2",
                "session_key": "获取到的session_key 2"
            }，
        }

## **OAuth 2.0 规范：知其然更知其所以然**

1. **OAuth 2.0 规范中的角色划分**

    咱们先思考一个问题：小程序登录之后如果需要访问用户的数据（比如昵称、地域、性别等）需要得到谁的授权？是微信？还是用户？

    答案是用户。首先了解一下OAuth 2.0规范中有哪些角色

    * **Resource Owner（资源所有者）：在小程序场景下代表小程序的用户。**
    * **Resource Server（资源服务器，即存放用户数据、资源的服务器）：在小程序场景下这个角色由微信服务器承担。**
    * **Third-party application（第三方应用程序/又称客户端）：在小程序场景下代表小程序。**
    * **User Agent（用户代理）：在小程序场景下代表微信。**

        小程序依托于微信提供的底层技术平台（即 01 讲中的双线程模型），微信为小程序提供了与用户（即Resource Owner）沟通的工具，它在 OAuth 2.0 规范中的角色被称为 User Agent（用户代理）。

    * **Authorization server（认证服务器）：在小程序场景下，这个角色由微信服务器承担。**
    * **HTTP Service（HTTP 服务提供商）：在小程序场景下，这个角色由微信服务器承担。**

        微信服务器不仅仅作为 Resource Server 保存用户数据，同时在登录授权过程中又提供了HTTP服务以及授权认证功能，这两个功能的角色在 OAuth 2.0 规范中分别被称为 HTTP Service（HTTP服务提供商）和Authorization server（认证服务器）。

    在小程序登录流程中的 3 个实体角色中，微信同时担任 Third-party application 和User Agent 的功能；微信服务器同时担任 Resource Server、Authorization server 和HTTP Service 的功能；开发者服务器比较特殊，它即担任 HTTP Service 的功能，同时在认证流程中由于需要转发和关联 token，所以也充当了客户端的一部分功能。

    而OAuth 2.0 规范如此分配角色，是为了规范一套严谨的授权流程。那么它到底解决了什么问题呢？

2. **OAuth 2.0 规范要解决什么问题**

    举个例子：你需要有人去你家帮你拿个东西，又不想把密码锁的密码暴露，就创建一个临时密码。

    OAuth 2.0 规范要解决的问题与上面提到的这个现实案例非常相似，简单概括就是：OAuth 2.0是一个授权机制，资源所有者告诉认证服务器，临时授予某个第三方应用访问资源服务器获取资源的权限，认证服务器给第三方应用颁发一个临时令牌，拥有这个令牌便可以获取资源数据，一旦令牌过期或失效便收回权限。
